<!DOCTYPE html>
<html lang=zh>
<head>
  <!-- so meta -->
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
  <meta name="description" content="Ditherpunk 系列第二篇。我们将核心抖动算法移植到 ESP32 上，驱动 ST7305 1.54 寸单色屏，实现从 Threshold 到 Blue Noise 的全套效果。">
<meta property="og:type" content="article">
<meta property="og:title" content="屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战">
<meta property="og:url" content="https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/index.html">
<meta property="og:site_name" content="Chaosgoo | ESP32, IoT &amp; Hardware DIY Blog">
<meta property="og:description" content="Ditherpunk 系列第二篇。我们将核心抖动算法移植到 ESP32 上，驱动 ST7305 1.54 寸单色屏，实现从 Threshold 到 Blue Noise 的全套效果。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chaosgoo.com/images/archives/Ditherpunk-The-Art-of-Dithering-2-ESP32/thumbnail.jpg">
<meta property="article:published_time" content="2025-12-30T05:38:00.000Z">
<meta property="article:modified_time" content="2025-12-30T05:38:00.000Z">
<meta property="article:author" content="Chaos Goo">
<meta property="article:tag" content="Embedded">
<meta property="article:tag" content="C">
<meta property="article:tag" content="ESP32">
<meta property="article:tag" content="Dithering">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chaosgoo.com/images/archives/Ditherpunk-The-Art-of-Dithering-2-ESP32/thumbnail.jpg">
    
      
        
          
                    <link rel="shortcut icon" href="/images/favicon_chaosgoo.ico">
                    
                      
                        
                          
                                    <link rel="icon" type="image/png" href="/images/Logo_Sketch.png"
                                      sizes="192x192">
                                    
                                      
                                        
                                          
                                                    <link rel="apple-touch-icon" sizes="180x180"
                                                      href="/images/Logo_Sketch.png">
                                                    
                                                      
                                                        
                                                          <!-- title -->
                                                          <title>
                                                            屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战
                                                          </title>
                                                          <link rel="canonical"
                                                            href="https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/">
                                                          <!-- async scripts -->
                                                          <!-- Google Analytics -->

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-EVWTNN57LZ"></script>
  <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-EVWTNN57LZ');
  </script>


                                                            <!-- Umami Analytics -->


                                                              <!-- styles -->
                                                              
<link rel="stylesheet" href="/css/style.css">

                                                                <!-- persian styles -->
                                                                
                                                                      <!-- rss -->
                                                                      
                                                                            
                                                                                <script async
                                                                                  src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1189115759021088"
                                                                                  crossorigin="anonymous"></script>
                                                                                <!-- mathjax -->
                                                                                
<meta name="generator" content="Hexo 6.3.0"></head>
<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2026/01/04/ESP-IDF-embed-txtfiles-tricks/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2025/12/22/Ditherpunk-The-Art-of-Dithering/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/&text=屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/&title=屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/&is_video=false&description=屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战&body=Check out this article: https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/&title=屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/&title=屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/&title=屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/&title=屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/&name=屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战&description=&lt;h2 id=&#34;0x00-序&#34;&gt;&lt;a href=&#34;#0x00-序&#34; class=&#34;headerlink&#34; title=&#34;0x00 序&#34;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;p&gt;在&lt;a href=&#34;/2025/12/22/Ditherpunk-The-Art-of-Dithering/&#34;&gt;上一篇文章&lt;/a&gt;中，我们在浏览器中通过 JavaScript 模拟了各种抖动算法的视觉效果。虽然原理通透了，但真正的挑战在于硬件端：&lt;strong&gt;如何在资源受限的嵌入式设备上复现这些效果？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文将记录我基于 ESP32-S3 和一块 1.54 寸 ST7305 单色屏的实战过程，探讨如何在单片机上实现从基础的阈值法到复杂的误差扩散等多种图像处理算法。&lt;/p&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/&t=屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00-%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">0x00 序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-%E7%A1%AC%E4%BB%B6%E7%8E%AF%E5%A2%83"><span class="toc-number">2.</span> <span class="toc-text">0x01 硬件环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-%E6%A0%B8%E5%BF%83%E6%8C%91%E6%88%98"><span class="toc-number">3.</span> <span class="toc-text">0x02 核心挑战</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.</span> <span class="toc-text">0x03 代码实现详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B-Gamma-%E6%9F%A5%E6%89%BE%E8%A1%A8-LUT"><span class="toc-number">4.1.</span> <span class="toc-text">建立 Gamma 查找表 (LUT)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%9AThreshold-Random"><span class="toc-number">4.2.</span> <span class="toc-text">基础算法：Threshold &amp; Random</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%8A%96%E5%8A%A8%EF%BC%9ABayer-Matrix"><span class="toc-number">4.3.</span> <span class="toc-text">有序抖动：Bayer Matrix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AF%E5%B7%AE%E6%89%A9%E6%95%A3%EF%BC%9AFloyd-Steinberg-Atkinson"><span class="toc-number">4.4.</span> <span class="toc-text">误差扩散：Floyd-Steinberg &amp; Atkinson</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%AB%E6%9C%89%E9%A3%8E%E5%91%B3%EF%BC%9ABlue-Noise-%E8%93%9D%E5%99%AA%E5%A3%B0"><span class="toc-number">4.5.</span> <span class="toc-text">别有风味：Blue Noise (蓝噪声)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">0x04 总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x05-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">6.</span> <span class="toc-text">0x05 参考资料</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Chaos Goo</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-12-30T05:38:00.000Z" class="dt-published" itemprop="datePublished">2025-12-30</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/Hardware-IoT/">Hardware & IoT</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/C/" rel="tag">C</a>, <a class="p-category" href="/tags/Dithering/" rel="tag">Dithering</a>, <a class="p-category" href="/tags/ESP32/" rel="tag">ESP32</a>, <a class="p-category" href="/tags/Embedded/" rel="tag">Embedded</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><p>在<a href="/2025/12/22/Ditherpunk-The-Art-of-Dithering/">上一篇文章</a>中，我们在浏览器中通过 JavaScript 模拟了各种抖动算法的视觉效果。虽然原理通透了，但真正的挑战在于硬件端：<strong>如何在资源受限的嵌入式设备上复现这些效果？</strong></p>
<p>本文将记录我基于 ESP32-S3 和一块 1.54 寸 ST7305 单色屏的实战过程，探讨如何在单片机上实现从基础的阈值法到复杂的误差扩散等多种图像处理算法。</p>
<span id="more"></span>

<h2 id="0x01-硬件环境"><a href="#0x01-硬件环境" class="headerlink" title="0x01 硬件环境"></a>0x01 硬件环境</h2><ul>
<li><strong>MCU</strong>: ESP32-S3 (当然，普通的 ESP32 甚至 ESP8266 也完全足以胜任)</li>
<li><strong>屏幕</strong>: 1.54 inch Monochrome Display 鱼鹰光电单色屏幕</li>
<li><strong>驱动</strong>: ST7305 (这种控制器也常见于一些黑白双色或黑白红三色的小尺寸墨水屏)</li>
<li><strong>分辨率</strong>: 200 x 200 (1-bit Monza, 纯黑白)</li>
</ul>
<p>选择 ESP32-S3 主要是因为其内置的大容量 SRAM（512KB+）和对 PSRAM 的支持，让我们在处理 200x200（只要 5KB）甚至更高分辨率的图像缓冲区时游刃有余。而 ST7305 是一款主要用于点阵电子纸显示器的驱动芯片，通过 SPI 接口通信。</p>
<h2 id="0x02-核心挑战"><a href="#0x02-核心挑战" class="headerlink" title="0x02 核心挑战"></a>0x02 核心挑战</h2><p>在 PC 网页端，我们有 <code>Float32Array</code> 和近乎无限的内存。但在 ESP32-S3 上，我们需要关注：</p>
<ol>
<li><strong>内存管理</strong>：尽量复用 Buffer，避免频繁 <code>malloc/free</code> 产生内存碎片。</li>
<li><strong>Gamma 校正</strong>：必须在 C 语言中手动实现 Gamma Table，否则画面会严重偏暗。</li>
<li><strong>驱动适配</strong>：屏幕通常需要较为复杂的 SPI 初始化序列，特别是针对不同的屏幕玻璃面板，需要配置正确的电压和驱屏波形。</li>
</ol>
<h2 id="0x03-代码实现详解"><a href="#0x03-代码实现详解" class="headerlink" title="0x03 代码实现详解"></a>0x03 代码实现详解</h2><p>项目工程结构如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main/</span><br><span class="line">├── blue_noise.h      // 预计算的蓝噪声纹理数组</span><br><span class="line">├── esp_lcd_st7305.c  // 屏幕驱动实现</span><br><span class="line">├── hello_world_main.c// 核心逻辑与算法实现</span><br><span class="line">└── sample_img.h      // 测试用灰度图片数组</span><br></pre></td></tr></table></figure>

<h3 id="建立-Gamma-查找表-LUT"><a href="#建立-Gamma-查找表-LUT" class="headerlink" title="建立 Gamma 查找表 (LUT)"></a>建立 Gamma 查找表 (LUT)</h3><p>正如第一篇所述，这是最关键的一步。如果不做 Gamma 校正，线性空间的抖动算法处理 sRGB 图片时，中间调会偏暗。由于 <code>powf</code> 函数在嵌入式上计算非常昂贵，我们绝对不能对每个像素实时计算。为了性能，我们在启动时预计算一个 256 长度的查找表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Gamma correction LUT (0-255 -&gt; 0.0-1.0 linear)</span></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> s_gamma_lut[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_gamma_lut</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// sRGB to Linear: ((val / 255.0) ^ 2.2)</span></span><br><span class="line">    s_gamma_lut[i] = powf(i / <span class="number">255.0f</span>, <span class="number">2.2f</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任何后续的像素读取，都通过 <code>s_gamma_lut[pixel]</code> 来获取其线性亮度值。这是一种经典的空间换时间策略。</p>
<h3 id="基础算法：Threshold-Random"><a href="#基础算法：Threshold-Random" class="headerlink" title="基础算法：Threshold &amp; Random"></a>基础算法：Threshold &amp; Random</h3><p>最简单的算法往往是很好的基准线。</p>
<p><strong>Threshold (阈值法)</strong> ：<br>也就是二值化。这是最快的方法，但也是效果最差的方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dither_threshold</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *src, <span class="type">uint8_t</span> *dst)</span> &#123;</span><br><span class="line">  <span class="built_in">memset</span>(dst, <span class="number">0</span>, ST7305_FRAMEBUFFER_SIZE);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ST7305_WIDTH * ST7305_HEIGHT; i++) &#123;</span><br><span class="line">    <span class="type">float</span> val = s_gamma_lut[src[i]];</span><br><span class="line">    <span class="type">bool</span> white = val &gt; <span class="number">0.5f</span>;</span><br><span class="line">    set_pixel_1bit(dst, i % ST7305_WIDTH, i / ST7305_WIDTH, white);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实拍效果</strong>：细节大量丢失，俗称“两色图”。它只能保留最硬的边缘，几乎完全丢失了所有的灰度信息。<br><img src="/images/archives/Ditherpunk-The-Art-of-Dithering-2-ESP32/Threshold.jpg" alt="Threshold 效果"></p>
<p><strong>Random (随机抖动)</strong><br>为了找回丢失的灰度，我们引入 <code>rand()</code> 来打破量化阶梯。通过给每个像素值增加一个随机噪声，使得原本在阈值附近的像素有一半概率翻转，从而宏观上表现出灰度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> noise = ((<span class="type">float</span>)rand() / RAND_MAX) - <span class="number">0.5f</span>; <span class="comment">// -0.5 to 0.5</span></span><br><span class="line"><span class="type">bool</span> white = (val + noise) &gt; <span class="number">0.5f</span>;</span><br></pre></td></tr></table></figure>
<p><strong>实拍效果</strong>：虽然有灰度感了，但画面非常脏，充满了白噪声。这种高频噪声在人眼看来就是“雪花点”，并不讨喜。<br><img src="/images/archives/Ditherpunk-The-Art-of-Dithering-2-ESP32/Random.jpg" alt="Random 效果"></p>
<h3 id="有序抖动：Bayer-Matrix"><a href="#有序抖动：Bayer-Matrix" class="headerlink" title="有序抖动：Bayer Matrix"></a>有序抖动：Bayer Matrix</h3><p>有序抖动非常适合没有 Framebuffer 的超低端单片机（如 Arduino Uno, ATtiny85），因为它是 <strong>Point-Operation（点操作）</strong>，不需要知道邻居像素的信息，也不需要存储上一行的误差。我们可以对每个像素独立计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">float</span> s_bayer_matrix[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0.0f</span> / <span class="number">16.0f</span>, <span class="number">8.0f</span> / <span class="number">16.0f</span>, <span class="number">2.0f</span> / <span class="number">16.0f</span>, <span class="number">10.0f</span> / <span class="number">16.0f</span>&#125;,</span><br><span class="line">    &#123;<span class="number">12.0f</span> / <span class="number">16.0f</span>, <span class="number">4.0f</span> / <span class="number">16.0f</span>, <span class="number">14.0f</span> / <span class="number">16.0f</span>, <span class="number">6.0f</span> / <span class="number">16.0f</span>&#125;,</span><br><span class="line">    <span class="comment">// ... complete matrix</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inside loop</span></span><br><span class="line"><span class="type">float</span> threshold = s_bayer_matrix[y % <span class="number">4</span>][x % <span class="number">4</span>];</span><br><span class="line"><span class="type">bool</span> white = (val &gt; threshold);</span><br></pre></td></tr></table></figure>
<p><strong>实拍效果</strong>：经典的十字交叉网纹。这种风格在复古 GameBoy 游戏和早期的 Macintosh 系统中非常常见。它通过规则的纹理来模拟灰度，虽然看起来有点“人工”，但比随机抖动干净得多。<br><img src="/images/archives/Ditherpunk-The-Art-of-Dithering-2-ESP32/Bayer.jpg" alt="Bayer 效果"></p>
<h3 id="误差扩散：Floyd-Steinberg-Atkinson"><a href="#误差扩散：Floyd-Steinberg-Atkinson" class="headerlink" title="误差扩散：Floyd-Steinberg &amp; Atkinson"></a>误差扩散：Floyd-Steinberg &amp; Atkinson</h3><p>对于支持 Framebuffer 的设备（ESP32 有足够 RAM），误差扩散是最佳选择。你需要一个浮点数 Buffer 来存储扩散过程中的误差。</p>
<p><strong>Floyd-Steinberg</strong> 是教科书般的标准，扩散系数为 <code>7, 3, 5, 1</code> (&#x2F;16)。它试图将量化产生的每一个误差都完美地分配给邻居，从数学上讲是最精确的。<br><strong>实拍效果</strong>：<br><img src="/images/archives/Ditherpunk-The-Art-of-Dithering-2-ESP32/FloydSteinberg.jpg" alt="Floyd-Steinberg 效果"></p>
<p><strong>Atkinson</strong> 则更适合这种高解析度但低色深的屏幕。它由 Bill Atkinson 设计，不像 Floyd-Steinberg 那样保留 100% 的误差，而是只保留 75% 的误差用于扩散，这就人为制造了一些“死黑”和“死白”区域。这听起来像是缺点，但在低对比度的单色屏上，但这反而增加了局部对比度，让图像看起来更清晰锐利，减少了“蠕虫”伪影。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Distribute 1/8 to neighbors (Atkinson)</span></span><br><span class="line"><span class="type">float</span> err_part = quant_error / <span class="number">8.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x + <span class="number">1</span> &lt; ST7305_WIDTH)</span><br><span class="line">  work_buf[y * ST7305_WIDTH + x + <span class="number">1</span>] += err_part;</span><br><span class="line"><span class="keyword">if</span> (x + <span class="number">2</span> &lt; ST7305_WIDTH)</span><br><span class="line">  work_buf[y * ST7305_WIDTH + x + <span class="number">2</span>] += err_part;</span><br><span class="line"><span class="comment">// ... bottom neighbors</span></span><br></pre></td></tr></table></figure>
<p><strong>实拍效果</strong>：这是我在这块屏上最喜欢的算法。线条硬朗，质感极佳，特别适合显示文字和 icon 混合的 UI 界面。<br><img src="/images/archives/Ditherpunk-The-Art-of-Dithering-2-ESP32/Atkinson.jpg" alt="Atkinson 效果"></p>
<h3 id="别有风味：Blue-Noise-蓝噪声"><a href="#别有风味：Blue-Noise-蓝噪声" class="headerlink" title="别有风味：Blue Noise (蓝噪声)"></a>别有风味：Blue Noise (蓝噪声)</h3><p>如果在嵌入式设备上想要模拟胶片感，蓝噪声是唯一的选择。它的计算成本和 Bayer 一样低（只需要查表），但效果却能通过“排列无序但分布均匀”的噪点来欺骗人眼。</p>
<p>我们需要将一张预计算好的蓝噪声纹理转换成 C 数组 (<code>blue_noise.h</code>) 存储在 Flash 中。这意味着你需要牺牲几十 KB 的 Flash 空间来换取这种效果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map 0-255 texture to 0.0-1.0</span></span><br><span class="line"><span class="type">float</span> threshold = blue_noise_map[(y % BN_H) * BN_W + (x % BN_W)] / <span class="number">255.0f</span>;</span><br><span class="line"><span class="type">bool</span> white = (val &gt; threshold);</span><br></pre></td></tr></table></figure>

<p><strong>实拍效果</strong>：非常自然的颗粒感，没有任何规律性条纹，就像一张老照片。这种算法特别适合显示人像和风景摄影。<br><img src="/images/archives/Ditherpunk-The-Art-of-Dithering-2-ESP32/BlueNoise.jpg" alt="Blue Noise 效果"></p>
<h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>在 ESP32 这种级别的 MCU 上，我们完全可以实现高质量的即时图像抖动。不同的算法适用于不同的场景：</p>
<ul>
<li><strong>Bayer 有序抖动</strong>：计算开销最小，适合资源极端受限（如不带 RAM 的低端单片机）或复古风格游戏。</li>
<li><strong>Atkinson</strong>：对比度最高，边缘清晰，适合 UI 界面、文字混排场景。</li>
<li><strong>Blue Noise</strong>：颗粒感自然，适合显示摄影图片，但需要额外的 Flash 空间存储纹理。</li>
</ul>
<p>希望本文能为你在单色屏幕开发中提供一些思路。</p>
<h2 id="0x05-参考资料"><a href="#0x05-参考资料" class="headerlink" title="0x05 参考资料"></a>0x05 参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Kevincoooool/esp_lcd_st7305">Kevincoooool&#x2F;esp_lcd_st7305</a> - 本文 ST7305 驱动移植参考</li>
<li><a target="_blank" rel="noopener" href="https://github.com/DuRuofu/esp-idf-st7305-Ink-screen">DuRuofu&#x2F;esp-idf-st7305-Ink-screen</a> - 另一个优秀的 ST7305 驱动实现</li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/about/">关于</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00-%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">0x00 序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-%E7%A1%AC%E4%BB%B6%E7%8E%AF%E5%A2%83"><span class="toc-number">2.</span> <span class="toc-text">0x01 硬件环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-%E6%A0%B8%E5%BF%83%E6%8C%91%E6%88%98"><span class="toc-number">3.</span> <span class="toc-text">0x02 核心挑战</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.</span> <span class="toc-text">0x03 代码实现详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B-Gamma-%E6%9F%A5%E6%89%BE%E8%A1%A8-LUT"><span class="toc-number">4.1.</span> <span class="toc-text">建立 Gamma 查找表 (LUT)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%9AThreshold-Random"><span class="toc-number">4.2.</span> <span class="toc-text">基础算法：Threshold &amp; Random</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%8A%96%E5%8A%A8%EF%BC%9ABayer-Matrix"><span class="toc-number">4.3.</span> <span class="toc-text">有序抖动：Bayer Matrix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AF%E5%B7%AE%E6%89%A9%E6%95%A3%EF%BC%9AFloyd-Steinberg-Atkinson"><span class="toc-number">4.4.</span> <span class="toc-text">误差扩散：Floyd-Steinberg &amp; Atkinson</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%AB%E6%9C%89%E9%A3%8E%E5%91%B3%EF%BC%9ABlue-Noise-%E8%93%9D%E5%99%AA%E5%A3%B0"><span class="toc-number">4.5.</span> <span class="toc-text">别有风味：Blue Noise (蓝噪声)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">0x04 总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x05-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">6.</span> <span class="toc-text">0x05 参考资料</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/&text=屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/&title=屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/&is_video=false&description=屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战&body=Check out this article: https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/&title=屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/&title=屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/&title=屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/&title=屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/&name=屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战&description=&lt;h2 id=&#34;0x00-序&#34;&gt;&lt;a href=&#34;#0x00-序&#34; class=&#34;headerlink&#34; title=&#34;0x00 序&#34;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;p&gt;在&lt;a href=&#34;/2025/12/22/Ditherpunk-The-Art-of-Dithering/&#34;&gt;上一篇文章&lt;/a&gt;中，我们在浏览器中通过 JavaScript 模拟了各种抖动算法的视觉效果。虽然原理通透了，但真正的挑战在于硬件端：&lt;strong&gt;如何在资源受限的嵌入式设备上复现这些效果？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文将记录我基于 ESP32-S3 和一块 1.54 寸 ST7305 单色屏的实战过程，探讨如何在单片机上实现从基础的阈值法到复杂的误差扩散等多种图像处理算法。&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/&t=屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
      
        
          2016-2026
            Chaos Goo
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       -->
          <li><a href="/privacy-policy/">
              隐私政策
            </a></li><!--
     -->
          <!--
       -->
          <li><a href="/terms/">
              使用条款
            </a></li><!--
     -->
          <!--
       -->
          <li><a href="/contact/">
              联系我们
            </a></li><!--
     -->
          <!--
       -->
          <li><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">
              皖ICP备2024054743号
            </a></li><!--
     -->
          
      </ul>
    </nav>
  </div>
</footer>
    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
